{"meta":{"title":"安晓凯的博客","subtitle":"野心有多大，未来就有多宽广","description":"可爱的小毒蛇","author":"安晓凯","url":"https://anxiaok.coding.me/myblog"},"pages":[{"title":"座右铭","date":"2017-07-30T06:20:18.000Z","updated":"2017-08-02T15:10:22.187Z","comments":true,"path":"tags/index.html","permalink":"https://anxiaok.coding.me/myblog/tags/index.html","excerpt":"","text":"野心有多大，未来就有多宽广！ 再多一点努力，就多一点希望！ 功成由勤，业精于勤！"},{"title":"JavaScript设计模式","date":"2017-08-05T14:19:40.000Z","updated":"2017-11-04T12:12:42.098Z","comments":true,"path":"share/index.html","permalink":"https://anxiaok.coding.me/myblog/share/index.html","excerpt":"","text":"分享人—安晓凯 什么是模式? 1，模式是一种可复用的解决方案。 2，设计模式的好处 a，模式是已经验证的解决方案； b，模式很容易被复用； c，模式富有表达力. 3，其他优点 a，复用模式有助于防止在应用程序开发过程中小问题引发的大问题 b，模式可以提供通用的解决方案，并且其记录方式不需要与某个特定问题挂钩 c，某些模式确实能够通过避免代码复用来减少代码的总体资源占用量 d，模式添加到开发人员的词汇中，会使沟通更快速 4，三法则 a，适合性 b，实用性 c，适用性 设计模式类别 1，创建型设计模式 Constructor(构造器)，Factory(工厂)，Abstract( 抽象)，Prototype(原型)，Singleton(单例)，Builder(生成器) 2，结构型设计模式 Decorator(装饰者)，Facade(外观)，Flyweight(享元)、Adapter(适配器)，Proxy(代理) 3，行为设计模式 Iterator(迭代器)，Mediator(中介者)、Observer(观察者)，Visitor(访问者) 重点： 1,Constructor(构造器)模式，2,Model(模块)模式，3,Revealing Model(揭示模块)模式，4,Singleton(单例)模式， 5,Observer(观察者)模式，6,Mediator(中介者)模式，7,Prototype(原型)模式，8,Command(命令)模式， 9,Facade(外观)模式，10,Factory(工厂)模式，11,Mixin模式，12,Decorator(装饰者)模式，13,Flyweight(享元)模式 Constructor(构造器)模式 创建空对象：var newObject = {}; var newObject = new Object(); 四种方法( 将键值 -&gt; 赋值给对象 ) 1，点语法 //设置属性 newObject.key = &apos;Hello World&apos;; //获取属性 var key = newObject.key; 2，中括号语法 //设置属性 newObject[&apos;key&apos;] = &apos;Hello World&apos;; //获取属性 var key = newObject[&apos;key&apos;]; 3，Object.defineProperty //设置属性（麻烦） Object.defineProperty(newObject, &apos;key&apos;,{ value:&apos;ananan&apos;, writable:true, enumerable:true, configurable:true }) //（简便） var defineProp = function(obj, key, value){ var config = {}; config.value = value; Object.defineProperty(obj, key, config); }; //例子 var person = Object.create(null); //创建一个空的person对象 defineProp(person,&apos;car&apos;,&apos;delorean&apos;); //然后设置各个属性 defineProp(person,&apos;dateOfBirth&apos;,&apos;1981&apos;); dfineProp(person,&apos;hasBeard&apos;,false) ★ 当然这些方法可以用于继承 var driver = Object.create(person); defineProp(driver,&apos;topSpeed&apos;,&apos;100mph&apos;); console.log(driver.dateOfBirth); console.log(driver.topSpeed); 基本Construtor(构造器) function Car(model, year, miles){ this.model = model; this.year = year; this.miles = miles; this.toString = function(){ return this.model + &apos;has done &apos; + this.miles + &apos; miles in &apos;+this.year; } } var civic = new Car(&apos;Honda Civic&apos;,2009,20000); var mondeo = new Car(&apos;Ford Mondeo&apos;,2001,5000); console.log(civic.toString()); console.log(mondeo.toString()); 基本Construtor(构造器) function Car(model, year, miles){ this.model = model; this.year = year; this.miles = miles; } Car.prototype.toString = function(){ return this.model + &apos;has done &apos; + this.miles + &apos; miles in &apos;+this.year; } var civic = new Car(&apos;Honda Civic&apos;,2009,20000); var mondeo = new Car(&apos;Ford Mondeo&apos;,2001,5000); console.log(civic.toString()); console.log(mondeo.toString()); Module(模块)模式 实现模块的方法◆ 对象字面量表示法 ◆ Module模式 ◆ AMD模块 ◆ CommonJs模块 ◆ ECMAScript Harmony 模块 对象字面量var myModel = { myProperty:&apos;anan&apos;, myConfig:{ useCaching:true, language:&apos;zh&apos; }, method1:function(){ console.log(&apos;method1&apos;); }, method2:function(){ console.log(&apos;method2&apos;); }, method3:function(newConfig){ if(typeof newConfig === &apos;object&apos;){ this.myConfig= newConfig; console.log(this.myConfig.language); } } }; myModel.method1(); myModel.method2(); myModel.method3({ language:&apos;de&apos;, useCaching:false }); Module(模块)模式 自包含模块 var testModule = (function(){ var counter = 0; return { incrementCounter:function(){ return counter++; }, resetCounter:function(){ console.log(&apos;重置数字：&apos;+counter); counter = 0; } }; })(); testModule.incrementCounter(); testModule.resetCounter(); 特定框架的Module模式实现Dojo，ExtJS，YUI，jQuery Module模式的优缺点优点： 从JavaScript的角度，相比真正封装的思想，它相对来说比较简洁，其次，它支持私有数据，在Module模式中，代码的公有部分能够接触私有部分。 缺点： 由于我们访问共有和私有成员的方式不同，当我们想改变可见性时，实际上我们要改变每一个曾经使用过该成员的地方。其次是私有方法不太灵活。 Revealing Module(揭示模块)模式 产生： 当想从另一个方法调用公有方法或访问公有变量时，必须要重复主对象的名称； 也不想当使用Module模式时，必须切换对象字面量表示法来让某种方法变成公有方法。 例子1var myRevealingModule = function(){ var privateVar = &apos;anan&apos;,publicVar = &apos;kaikai&apos;; function privateFunction(){ console.log(&apos;name:&apos;+privateVar); } function publicSetName(strName){ privateVar = strName; } function publicGetName(){ privateFunction(); } return { setName:publicSetName, greeting:publicVar, getName:publicGetName }; }(); myRevealingModule.setName(&apos;anxiaokai&apos;); myRevealingModule.getName(); console.log(myRevealingModule.greeting); 例子2var myRevealingModule = function(){ var privateCounter = 0; function privateFunction(){ privateCounter++; } function publicFunction(){ publicIncrement(); } function publicIncrement(){ privateFunction(); } function publicGetCount(){ return privateCounter; } return { start:publicFunction, increment:publicIncrement, count:publicGetCount } }(); myRevealingModule.start(); myRevealingModule.start(); myRevealingModule.start(); console.log(myRevealingModule.count()); 优缺点优点： 该模式可以使脚本语法更加一致，在模块代码底部，它也会很容易指出哪些函数和变量可以被公开访问，改善了可读性。 缺点： 如果一个私有函数引用一个公有函数，在需要打补丁的时候，公有函数是不能被覆盖的， 因为私有函数将继续引用私有实现，该模式并不适用于公有成员，只适用于函数 Singleton (单例)模式 特点： 它限制了类的实例化次数只能是一次。 例子var mySingleton = (function(){ var instance; function init(){ function privateMethod(){ console.log(&apos;I am private&apos;); } var privateVariable = &apos;I am also private&apos;; var privateRandomNumber = Math.random(); return{ publicMethod:function(){ console.log(&apos;The public can see me!&apos;); }, publicProperty:&apos;I am also public&apos;, getRandomNumber:function(){ return privateRandomNumber; } }; } return{ //获取Singleton的实例，如果存在就返回，不存在就创建新实例 getInstance:function(){ if(!instance){ instance = init(); } return instance; } } })(); var myBadSingleton = (function(){ var instance; function init(){ var privateRandomNumber = Math.random(); return{ getRandomNumber:function(){ return privateRandomNumber; } }; } return { //每次都创建新实例 getInstance:function(){ instance = init(); return instance; } }; })(); var singleA = mySingleton.getInstance(); var singleB = mySingleton.getInstance(); console.log(singleA.getRandomNumber() === singleB.getRandomNumber()); var badSingleA = myBadSingleton.getInstance(); var badSingleB = myBadSingleton.getInstance(); console.log(badSingleA.getRandomNumber() !== badSingleB.getRandomNumber()); 在上下文中模式的使用var SingletonTester = (function(){ function Singleton(options){ this.name = &apos;singletonTester&apos;; this.pointX = options.pointX || 6; this.pointY = options.pointX || 10; } var instance; var _static = { name:&apos;SingletonTester&apos;, getInstance:function(options){ if(instance === undefined){ instance = new Singleton(options); } return instance; } }; return _static; })(); var singletonTest = SingletonTester.getInstance({ pointX:5 }); console.log(singletonTest.pointX); 扩展Singleton很有使用价值，它的存在表面系统中的模块要么是系统紧密耦合，要么是其逻辑过于分散在代码库中的多个部分。 Observer(观察者)模式 定义：一个对象维持一系列依赖于它的对象，将有关状态的任何变更自动通知给它们。 通俗点讲：A对象(观察者)对B对象(被观察者)的某种变化高度敏感，需要在B变化的一瞬间做出反应。 观察者不需要时刻盯着被观察者（例如A不需要每隔1ms就检查一次B的状态）， 二是采用注册(_Register_)或者成为订阅(_Subscribe_)的方式告诉被观察者：我需要你的某某状态，你要在它变化时通知我。 采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度 Subject(目标)：维护一系列的观察者，方便添加或删除观察者。 Observer(观察者)：为那些在目标发生改变时需获得通知的对象提供一个更新接口。 ConcreateSubject(具体目标)：状态发生改变时，向Observer发出通知，储存ConcreateObserver的状态。 ConcreateObserver(具体观察者):存储一个指向ConcreateSubject的引用，实现Observer的更新接口，以使自身状态与目标的状态保持一致。 链接：http://www.jianshu.com/p/d55ee6e83d66"},{"title":"links","date":"2017-11-04T07:24:18.000Z","updated":"2017-11-04T07:24:18.241Z","comments":true,"path":"links/index.html","permalink":"https://anxiaok.coding.me/myblog/links/index.html","excerpt":"","text":""},{"title":"links","date":"2017-11-04T07:24:18.000Z","updated":"2017-11-04T07:24:18.241Z","comments":true,"path":"about/index.html","permalink":"https://anxiaok.coding.me/myblog/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-08-05T14:19:40.000Z","updated":"2017-11-04T11:37:59.844Z","comments":true,"path":"categories/index.html","permalink":"https://anxiaok.coding.me/myblog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"gulp步骤","slug":"gulp步骤","date":"2017-11-18T00:08:20.000Z","updated":"2017-11-18T00:54:46.317Z","comments":true,"path":"2017/11/18/gulp步骤/","link":"","permalink":"https://anxiaok.coding.me/myblog/2017/11/18/gulp步骤/","excerpt":"","text":"gulp的安装 npm i -g gulp npm i gulp npm i -D gulp 开始使用gulp 创建gulpfile.js文件：var gulp = require(&apos;gulp&apos;); gulp.task(&apos;task1&apos;,function(){ console.log(&apos;欢迎来到晓凯博客&apos;); }); 运行：gulp +任务名 gulp的API gulp.task() gulp.src() gulp.dest() gulp.watch() gulp.src()：Gulp是以stream为媒介的，它不需要频繁的生成临时文件，这也是Gulp的速度比Grunt快的一个原因; gulp.src()方法正是用来获取流的，但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流(Vinyl files)，这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息 语法： gulp.src(globs[, options]) * 匹配文件路径中的0个或多个字符，但不会匹配路径分隔符，除非路径分隔符出现在末尾 ** 匹配路径中的0个或多个目录及其子目录,需要单独出现，即它左右不能有其他东西了。如果出现在末尾，也能匹配文件。 ? 匹配文件路径中的一个字符(不会匹配路径分隔符) [...] 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为^或!时，则表示不匹配方括号中出现的其他字符中的任意一个，类似js正则表达式中的用法 !(pattern|pattern|pattern) 匹配任何与括号中给定的任一模式都不匹配的 ?(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或1次，类似于js正则中的(pattern|pattern|pattern)? +(pattern|pattern|pattern)匹配括号中给定的任一模式至少1次，类似于js正则中的(pattern|pattern|pattern)+ *(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或多次，类似于js正则中的(pattern|pattern|pattern)* @(pattern|pattern|pattern) 匹配括号中给定的任一模式1次，类似于js正则中的(pattern|pattern|pattern) 一些例子如下： * 能匹配 a.js,x.y,abc,abc/,但不能匹配a/b.js *.* 能匹配 a.js,style.css,a.b,x.y */*/*.js 能匹配 a/b/c.js,x/y/z.js,不能匹配a/b.js,a/b/c/d.js ** 能匹配 abc,a/b.js,a/b/c.js,x/y/z,x/y/z/a.b,能用来匹配所有的目录和文件 **/*.js 能匹配 foo.js,a/foo.js,a/b/foo.js,a/b/c/foo.js a/**/z 能匹配 a/z,a/b/z,a/b/c/z,a/d/g/h/j/k/z a/**b/z 能匹配 a/b/z,a/sb/z,但不能匹配a/x/sb/z,因为只有单**单独出现才能匹配多级目录 ?.js 能匹配 a.js,b.js,c.js a?? 能匹配 a.b,abc,但不能匹配ab/,因为它不会匹配路径分隔符 [xyz].js 只能匹配 x.js,y.js,z.js,不会匹配xy.js,xyz.js等,整个中括号只代表一个字符 [^xyz].js 能匹配 a.js,b.js,c.js等,不能匹配x.js,y.js,z.js 当有多种匹配模式的时候可以使用数组： gulp.src([&apos;js/*.js&apos;,&apos;css/*.css&apos;,&apos;*.html&apos;]) 使用数组的方式还有一个好处就是可以很方便的使用排除模式，在数组中的单个匹配模式前加上!即是排除模式，它会在匹配的结果中排除这个匹配，要注意一点的是不能在数组中的第一个元素中使用排除模式 gulp.src([*.js,&apos;!b*.js&apos;]) //匹配所有js文件，但排除掉以b开头的js文件 gulp.src([&apos;!b*.js&apos;,*.js]) //不会排除任何文件，因为排除模式不能出现在数组的第一个元素中 a{b,c}d 会展开为 abd,acd a{b,}c 会展开为 abc,ac a{0..3}d 会展开为 a0d,a1d,a2d,a3d a{b,c{d,e}f}g 会展开为 abg,acdfg,acefg a{b,c}d{e,f}g 会展开为 abdeg,acdeg,abdeg,abdfg gulp.dest()：它是用来写文件的，语法为： gulp.dest(path[,options]) 例如： var gulp = require(&apos;gulp&apos;); gulp.src(&apos;script/jquery.js&apos;) .pipe(gulp.dest(&apos;dist/foo.js&apos;)); //最终生成的文件路径为 dist/foo.js/jquery.js,而不是dist/foo.js 要想改变文件名，可以使用插件gulp-rename 例子： var gulp = reruire(&apos;gulp&apos;); //有通配符开始出现的那部分路径为 **/*.js gulp.src(&apos;script/**/*.js&apos;) .pipe(gulp.dest(&apos;dist&apos;)); //最后生成的文件路径为 dist/**/*.js //如果 **/*.js 匹配到的文件为 jquery/jquery.js ,则生成的文件路径为 dist/jquery/jquery.js gulp.src(&apos;script/avalon/avalon.js&apos;) //没有通配符出现的情况 .pipe(gulp.dest(&apos;dist&apos;)); //最后生成的文件路径为 dist/avalon.js //有通配符开始出现的那部分路径为 **/underscore.js gulp.src(&apos;script/**/underscore.js&apos;) //假设匹配到的文件为script/util/underscore.js .pipe(gulp.dest(&apos;dist&apos;)); //则最后生成的文件路径为 dist/util/underscore.js gulp.src(&apos;script/*&apos;) //有通配符出现的那部分路径为 * //假设匹配到的文件为script/zepto.js .pipe(gulp.dest(&apos;dist&apos;)); //则最后生成的文件路径为 dist/zepto.js 了解base参数： gulp.src(script/lib/*.js) //没有配置base参数，此时默认的base路径为script/lib //假设匹配到的文件为script/lib/jquery.js .pipe(gulp.dest(&apos;build&apos;)) //生成的文件路径为 build/jquery.js gulp.src(script/lib/*.js, {base:&apos;script&apos;}) //配置了base参数，此时base路径为script //假设匹配到的文件为script/lib/jquery.js .pipe(gulp.dest(&apos;build&apos;)) //此时生成的文件路径为 build/lib/jquery.js gulp.task()：gulp.task方法用来定义任务，内部使用的是Orchestrator，其语法为： gulp.task(name[, deps], fn) 特殊情况，含有异步的时候： gulp.task(&apos;one&apos;,function(){ //one是一个异步执行的任务 setTimeout(function(){ console.log(&apos;one is done&apos;) },5000); }); //two任务虽然依赖于one任务,但并不会等到one任务中的异步操作完成后再执行 gulp.task(&apos;two&apos;,[&apos;one&apos;],function(){ console.log(&apos;two is done&apos;); }); 三种方法解决异步之后运行其他任务： 第一种： gulp.task(&apos;one&apos;,function(cb){ //cb为任务函数提供的回调，用来通知任务已经完成 //one是一个异步执行的任务 setTimeout(function(){ console.log(&apos;one is done&apos;); cb(); //执行回调，表示这个异步任务已经完成 },5000); }); //这时two任务会在one任务中的异步操作完成后再执行 gulp.task(&apos;two&apos;,[&apos;one&apos;],function(){ console.log(&apos;two is done&apos;); }); 第二种： gulp.task(&apos;one&apos;,function(cb){ var stream = gulp.src(&apos;client/**/*.js&apos;) .pipe(dosomething()) //dosomething()中有某些异步操作 .pipe(gulp.dest(&apos;build&apos;)); return stream; }); gulp.task(&apos;two&apos;,[&apos;one&apos;],function(){ console.log(&apos;two is done&apos;); }); 第三种： var Q = require(&apos;q&apos;); //一个著名的异步处理的库 https://github.com/kriskowal/q gulp.task(&apos;one&apos;,function(cb){ var deferred = Q.defer(); // 做一些异步操作 setTimeout(function() { deferred.resolve(); }, 5000); return deferred.promise; }); gulp.task(&apos;two&apos;,[&apos;one&apos;],function(){ console.log(&apos;two is done&apos;); }); gulp.watch()：第一种方式： gulp.task(&apos;uglify&apos;,function(){ //do something }); gulp.task(&apos;reload&apos;,function(){ //do something }); gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]); 第二种方式： gulp.watch(&apos;js/**/*.js&apos;, function(event){ console.log(event.type); //变化类型 added为新增,deleted为删除，changed为改变 console.log(event.path); //变化的文件的路径 }); 常用的gulp插件链接：https://www.cnblogs.com/2050/p/4198792.html","categories":[],"tags":[]},{"title":"javascript-标准对象","slug":"javascript-标准对象","date":"2017-08-19T12:26:17.000Z","updated":"2017-11-04T12:18:45.716Z","comments":true,"path":"2017/08/19/javascript-标准对象/","link":"","permalink":"https://anxiaok.coding.me/myblog/2017/08/19/javascript-标准对象/","excerpt":"","text":"typeof操作符 typeof 123; //&apos;number&apos; typeof NaN; //&apos;number&apos; typeof &apos;str&apos;; //&apos;string&apos; typeof true; //&apos;boolean&apos; typeof undefined; //&apos;undefined&apos; typeof Math.abs; //&apos;function&apos; typeof null; //&apos;object&apos; typeof []; //&apos;object&apos; typeof {}; //&apos;object&apos; 包装对象（用new 创建）：类型会都变成object；不写new就会被当做普通函数，比如：Number(),Boolean(),String(); 注意： 不要使用new Number()、new Boolean()、new String()创建包装对象； 用parseInt()或parseFloat()来转换任意类型到number； 转string用对象的toString()方法； typeof可以判断出number,boolean,string,function.undefined; 判断Array要使用Array.isArray(arr); 判断null使用myVar === null 判断某个全局变量是否存在typeof myVar === &#39;undefined&#39; null和undefined没有toString()方法，number对象调用toString()要加括号； Date对象 var now = new Date(); now.getFullYear(); now.getMonth(); now.getDate(); now.getDay(); //星期 now.getHours(); now.getMinutes(); now.getSeconds(); now.getMilliseconds(); //毫秒 now.getTime(); //以number形式表示的时间戳 var d = new Date(2017,8,19,21,08,123); d; //Tue Sep 19 2017 21:10:03 GMT+0800(月份+1) var d = Date.parse(&apos;Tue Sep 19 2017 21:10:03 GMT+0800&apos;); d; //1505826603000 * 显示本地时间和调整后的UTC时间 var d = new Date(1505826603000); d.toLocaleString(); d.toUTCString(); * 获取当前时间戳 if (Date.now) { alert(Date.now()); // 老版本IE没有now()方法 } else { alert(new Date().getTime()); } RegExp \\d：数字 \\w:字母或数字 .:可以匹配任意字符 *：表示任意个字符（包括0个） +：表示至少一个字符 ?:表示0个或1个字符 {n}:表示n个字符 {n,m}:表示n到m个字符 []:表示范围 A|B:匹配A或B ^：行的开头 $:行的结束 ():表示的是分组 ?:采用的是非贪婪匹配 g:全局匹配 i:忽略大小写 m:执行多行匹配 字符串中的两个\\\\表示一个\\ 方法 test()；正则.test(str); &apos;a,b,; c d&apos;.split(/[\\s\\,\\;]/); //[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;] exec();正则.exec();提取子串，返回一个Array，分别表示，第一个元素表示整个字符串，后面的表示子串，匹配失败返回null; 贪婪匹配 var re = /^(\\d+?)(0*)$/; re.exec(‘102300’); //[‘102300’,’1023’,’00’] 全局匹配可以多次执行exec()方法来搜索一个匹配的字符串，指定g标志后，每次运行exec()，正则都会更新lastIndex属性，表示上次匹配到的最后索引 var s = ‘JavaScript, VBScript, JScript and ECMAScript’;var re=/[a-zA-Z]+Script/g; // 使用全局匹配:re.exec(s); // [‘JavaScript’]re.lastIndex; // 10 re.exec(s); // [‘VBScript’]re.lastIndex; // 20 re.exec(s); // [‘JScript’]re.lastIndex; // 29 re.exec(s); // [‘ECMAScript’]re.lastIndex; // 44 re.exec(s); // null，直到结束仍没有匹配到","categories":[],"tags":[]},{"title":"javascript-函数","slug":"javascript-函数","date":"2017-08-06T02:31:22.000Z","updated":"2017-11-04T08:47:47.303Z","comments":true,"path":"2017/08/06/javascript-函数/","link":"","permalink":"https://anxiaok.coding.me/myblog/2017/08/06/javascript-函数/","excerpt":"","text":"函数 arguments,它指向当前函数调用者的所有参数。 rest参数: function foo(a,b,...rest){ console.log(a); console.log(b); console.log(rest); } foo(1,2,3,4,5); //1;2;[3,4,5]; 重点：内部函数可以访问外部函数定义的变量，反之则不行；函数在查找自身定义开始，就是从内向外查找；它会把所有申明的变量提升到函数顶部；在函数内部首先申明所有变量；减少冲突的一个方法是把自己多有的变量和函数全部绑定到一个全局变量中。比如：定义一个全局变量：var MYAPP = {}； 局部作用域:在for循环等语句块中是无法定义局部作用域的变量的。用let替代var可以申明一个块级作用域的变量。const定义一个常量，与let都具有块级作用域。 绑定到对象上的函数称为方法， this:它指向当前对象，var fn = xiaoming.age;fn();//NaN ECMA决定，在strict模式下，会得到一个一个错误，undefined; 所以用var that = this;在函数内部一开始就捕获this； apply和call方法：apply方法：接受两个参数，第一个参数是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。它是把参数打包成Array再传入。call方法：是参数按照顺序传入。 Math.max.apply(null,[2,5,4]);//5 Math.max.call(null,2,5,4);//5 比如：装饰器： var count = 0; var oldParseInt = parseInt; window.parseInt = function(){ count += 1; return oldParseInt.apply(null,arguments); } parseInt(&apos;10&apos;); parseInt(&apos;20&apos;); parseInt(&apos;30&apos;); count;//3 高阶函数：一个函数可以接受另一个函数作为参数.比如： function add(x,y,f){ return f(x)+f(y); } map():它定义在JavaScript的Array中，arr.map(自己的函数);比如： function pow(x){ return x*x; } var arr = [1,2,3,4,5]; arr.map(pow);//[2,4,9,16,25] 把Array的所有数字都转为字符串： var arr = [1,2,3,4,5]; arr.map(String);//[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;] reduce();它必须接受两个参数，它把结果继续和序列的下一个元素做累积计算。效果是：[x1,x2,x3].reduce(f) = f(f(x1,x2),x3); filter():把数组的某些元素过滤掉，然后返回剩下的元素。 比如： var arr = [1,2,3,4,5]; var r = arr.filter(function(x){ return x%2 !=0; }); r;//[1,3,5] 1, 去掉数组中的空字符串： var arr = [&apos;A&apos;,&apos;B&apos;,null,undefined,&apos;C&apos;,&apos;&apos;]; var r = arr.filter(function(s){ return s &amp;&amp; s.tirm(); }); r;//[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;] 注意：它接收的回调函数可以有多个参数，分别是：每一个元素，元素的位置和元素本身； sort();比如： var arr = [10,20,1,2]; arr.sort(function(x,y){ if(x&lt;y){ return -1; } if(x &gt; y){ return 1; } return 0； });//[1,2,10,20] 对字符串排序，就是把字符串变成大写或者小写进行比较。 var arr = [&apos;Goold&apos;,&apos;Microsoft&apos;,&apos;apple&apos;]; arr.sort(function(s1,s2){ x1 = s1.toUpperCase(); x2 = s2.toUpperCase(); if(x1&gt;x2){ return 1; } if(x1&lt;x2){ return -1; } return 0; });//[&apos;apple&apos;,&apos;Goold&apos;,&apos;Microsoft&apos;] sort()方法直接对数组进行修改，所以结果仍然是当前Array 闭包：函数中定义了函数，，并且内部函数可以引用外部函数的参数和局部变量，当外部函数返回内部函数时，相关参数和变量都保存在返回的函数中，这种称为闭包。 function count(){ var arr = []; for(var i=1;i&lt;=3;i++){ arr.push(function(){ return i*i; }); } return arr; } var results = count(); var f1 = results[0]; var f2 = results[1]; var f3 = results[2]; f1();//16 f2();//16 f3();//16 解析：返回的函数引用了变量i,但是并非立即执行；i=4; function count(){ var arr = []; for(var i=1;i&lt;=3;i++){ arr.push((function(n){ return n*n; })(i)); } return arr; } var results = count(); var f1 = results[0]; var f2 = results[1]; var f3 = results[2]; alert(f1()); 注意： 返回函数不要引用任何循环变量，或者后续会发生的变量。 利用闭包创建x的平方。 function make_pow(n){ return function(x){ return Math.pow(x,n); } } var pow2 = make_pow(2); var pow3 = make_pow(3); pow2(5); //25 pow3(5); //125 箭头函数 x =&gt; x*x; x =&gt; { if(x&gt;0){ return x*x; }else{ return -x*x; } } (x,y) =&gt; x*x+y*y; (x,y,...rest) =&gt; { var i,sum = x+y; for(i=0;i&lt;rest.length;i++){ sum+=rest[i]; } return sum; } x =&gt; ({foo:x}); generator函数 function* foo(x){ yield x+1; yield x+2; return x+3; } function* fib(max){ var t,a=0,b=1,n=1; while(n&lt;max){ yield a; t = a+b; a = b; b = t; n++; } return a; } var f = fib(5); f.next(); // {value: 0, done: false} f.next(); // {value: 1, done: false} f.next(); // {value: 1, done: false} f.next(); // {value: 2, done: false} f.next(); // {value: 3, done: true} 返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。","categories":[],"tags":[]},{"title":"Javascript-快速入门","slug":"javascript技术每日分享","date":"2017-08-05T14:19:40.000Z","updated":"2017-11-04T08:47:48.795Z","comments":true,"path":"2017/08/05/javascript技术每日分享/","link":"","permalink":"https://anxiaok.coding.me/myblog/2017/08/05/javascript技术每日分享/","excerpt":"","text":"Javascript基础： &amp;&amp;运算时与运算，只有所有都为true,&amp;&amp;运算结果才是true; ||运算时或运算，只要其中一个是true,||运算结果就是true; 特别注意相等运算符=: ==会自动转换为数据类型再比较; ===它不会自动转换为数据类型，如果数据类型不一致，返回false。如果一致，再比较。 所以不要使用==比较，始终坚持使用===比较。 判断 判断NaN的方法通过isNaN()函数；比如：isNaN(NaN); 比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个范围值：Math.abs(1/3-(1-2/3))&lt;0.0000001;//true; null和undefined: null表示一个空的值，它和0以及空字符串不同，0是一个数值，空字符串表示长度为0的字符串，而null表示为空 null表示一个空的值，undefined表示未定义；大多数情况下我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。 数组 创建数组：new Array(1,2,3)or [];索引起始值为0； 启用strict模式,use strict 取得数组的长度：arr.length; 直接给length赋值，会导致Array大小的变化；比如: var arr = [1,2,3]; arr.length;//3; arr.length = 6; arr;//[1,2,3,undefined,undefined,undefined] arr.length = 2; arr;//arr变为[1,2]; 对数组的索引进行赋值会直接修改为这个Array； 方法： indexOf();指定元素的位置 slice();对应string的subString()版本；比如： var arr = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;]; arr.slice(0,3);//从0开始到索引3（不包括3）结束 arr.slice(3); push()和pop();push 是向数组的末尾添加若干元素，pop是把数组的最后一个元素删掉 unshift()和shift();unshift是往数组的头部添加若干元素，shift是把数组的第一个元素删掉 sort();排序，会修改元素的默认顺序； reverse();把数组进行反转，都掉个个； splice();它是修改数组的万能方法； var arr = [0,1,2,3,4,5]; arr.splice(2,3,6,7);//从索引2开始删除3个元素，然后在索引2和3的位置添加两个元素，6和7；[0,1,6,7,5] arr.splice(2,2);//只删除，不添加；[0,1,4,5] arr.splice(2,0,&apos;6&apos;,&apos;7&apos;);//只添加不删除；[0,1,6,7,2,3,4,5] concat();连接两个不同的数组，返回一个新的数组；注意：它并没有修改当前array； join();把数组变成字符串，用特殊字符串连接；arr.join(‘-‘); 字符串 ASCII字符可以以\\x##表示十六进制，\\u####表示一个Unicode字符，比如\\x41 =&gt; A ，\\u4e2d\\u6587 =&gt;中文 多行字符串： var name =&apos;小明&apos;； var age = &apos;20； var message = \\`你好，${name},你今年${age}岁了！\\`； 注意：它有length属性，但是对字符串的某个索引赋值，是没有任何效果的，也不会报错；toUpperCase();把字符串变成小写；toLowerCase();把字符串变成大写；indexOf();指定字符串出现的位置；subString();返回指定索引区间的子串，比如： var s = &quot;hello,world&quot;; s.subString(0,5);//从索引0到5（不包括5）,返回&apos;hello&apos; s.subString(7);//从索引7开始到结束，返回&apos;world&apos; 对象 如果属性名包含特殊的字符，就必须用&#39;&#39;括起来；返回不存在的属性不会报错，而是返回undefined； 可以自由的给对象添加属性或者删除属性；delete xiaoming.age;检测对象是否有某一属性，可以用in操作符；&#39;name&#39; in xiaoming;注意:如果in判断一个属性存在，这个属性不一定是xiaoming的，塔可能是集成得到的；要判断是否是xiaoming自身拥有的，而不是继承得到的，用hasOwnProperty(); 循环 for循环如果没有退出循环的条件，就必须使用break语句退出循环； for…in…循环，可以把对象的所有属性都依次循环出来；要过滤掉对象继承的属性，可以用hasOwnProperty()来实现；比如： var o = { name:&apos;anan&apos;, age:20, city:&apos;beijing&apos; }; for (var key in o){ if(o.hasOwnProperty(key)){ alert(key); } } Map和Set； var m = new Map([[&apos;anna&apos;,95],[&apos;Bob&apos;,80],[&apos;Trancy&apos;,90]]); m.get(&apos;anna&apos;); //95 var m = new Map(); m.set(&apos;anna&apos;,90);m.set(&apos;nana&apos;,80);m.set(&apos;adam&apos;,60); m.get(&apos;adam&apos;);//60 m.delete(&apos;adam&apos;); m.get(adam);//undefined; var s = new Set([1,2,3,3,4]);s;//Set{1,2,3,4} s.add(4);s.add(4);s;//重复添加，还是没有任何的变化； s.delete(3);s;//Set{1,2,4}; iterable类型，Array,Map,Set都属于iterable类型；具有iterable类型的集合可以通过新的for…of…循环来遍历；它只循环集合本身的元素；方法：forEach(); var s = new Set([&apos;A&apos;,&apos;B&apos;,&apos;C&apos;]); s.forEach(function(element,sameElement,set){ alert(element); }); 注意：Set和Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身；map的回调函数参数依次为value，key和map本身； var m = new Map([[1,&apos;x&apos;],[2,&apos;y&apos;],[3,&apos;z&apos;]]); m.forEach(function(value,key,map){ alert(value); }); 由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们； var a = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;]; a.forEach(function(element){ alert(element); });","categories":[],"tags":[]}]}